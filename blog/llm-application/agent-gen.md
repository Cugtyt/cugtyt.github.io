# LLM Generates Tokens, Agent Generates Messages, AgentLauncher Generates Agents

## Contact Me

- Blog: <https://cugtyt.github.io/blog/llm-application/index>
- Email: <cugtyt@qq.com>
- GitHub: [Cugtyt@GitHub](https://github.com/Cugtyt)

---

Understanding the fundamental differences between these three components is crucial for building effective AI systems. Each operates at a different abstraction level, with distinct inputs and outputs that work together to create intelligent behavior.

## LLM (Large Language Model)

* **Input**: Takes tokens as input
* **Generation unit**: Token
* **Role**: The foundational text generation engine that processes and produces individual tokens

## Agent

* **Input**: Takes messages as input  
* **Generation unit**: Message
* **Role**: Orchestrates conversations and tool interactions to accomplish complex tasks

## AgentLauncher

* **Input**: Takes task specifications as input
* **Generation unit**: Agent (a standard loop that iterates through LLM calls and tool calls until the task is completed)
* **Role**: Creates and configures agents with the appropriate tools and capabilities

## What Needs to be Done

Since the AgentLauncher serves as the orchestrator of agents, we need to standardize the agent lifecycle and all interfaces within this lifecycle. This standardization ensures consistency and interoperability across different agent implementations.

### Standardize the Message Interface

The first step is standardizing the message interface, which defines the input and output formats for agents. The commonly used message types in modern systems include:

- **User message**: Direct input from users
- **System message**: Configuration and behavioral instructions  
- **Assistant message**: Responses generated by the agent
- **Tool call message**: Requests to execute specific tools or functions
- **Tool result message**: Results returned from tool executions

These message types form the communication backbone that enables agents to interact effectively with users, systems, and tools.

### Standardize the LLM Call Interface

The LLM call drives the agent's decision-making process, so we need to standardize this interface for consistency across different implementations.

**Input**: A list of messages containing:
- User message
- System message
- Assistant message
- Tool call message
- Tool result message

**Output**: A list of messages containing:
- Assistant message
- Tool call message

The key insight is that if the output contains a tool call message, it indicates the agent's logic should continueâ€”the agent will execute the tool and receive a tool result message. If no tool call message is present, the agent's task is complete.

### Standardize the Tool Interface

Tool calls represent the agent's actions and form the core of the agent's interaction with its environment. We need to standardize the tool interface to ensure consistent behavior.

**Tool Schema Components**:
- **Name**: Unique identifier for the tool
- **Description**: Clear explanation of the tool's purpose and functionality
- **Parameters**: Structured definition of required inputs and their data types

**Tool Execution Process**:
- **Tool Discovery**: Find the appropriate tool by name from the available tool set
- **Tool Execution**: Execute the tool with the provided parameters  
- **Result Generation**: Return the tool result message in standardized format

### Standardize the Agent Lifecycle

The agent lifecycle is a standard loop that iterates through LLM calls and tool calls until the task is completed. We can define the agent lifecycle with these key components:

**Core Components**:
* **conversation**: List of messages that contains all messages throughout the agent lifecycle
* **tool_set**: List of tools that the agent can access and utilize
* **llm_call**: Function that takes the conversation and generates the next messages  
* **tool_call**: Function that takes a tool call message and tool set, then generates the tool result message
* **break condition**: If the LLM output messages contain a tool call message, continue the loop; otherwise, break the loop

**Implementation**:

```
function agent_life_cycle(system_message, user_message, llm_call, tool_call):
    # system_message is optional
    conversation = [system_message, user_message]
    tool_set = [tool1, tool2, ...]

    while True:
        llm_output_messages = llm_call(conversation, tool_set)
        conversation.extend(llm_output_messages)
        if tool_call_message in llm_output_messages:
            tool_result_message = tool_call(tool_call_message, tool_set)
            conversation.append(tool_result_message)
        else:
            break
    return conversation
```

## Benefits of Standardization

With this standardized agent lifecycle, we can generate different agents by simply changing the components. For example, we can implement an agent launcher that builds each component based on configuration parameters, then launches the agent lifecycle with these customized components.

This modular approach enables:
* **Flexibility**: Different LLM providers, tool sets, and configurations can be easily swapped
* **Reusability**: Standard interfaces allow components to be reused across different agent implementations  
* **Scalability**: Complex multi-agent systems can be built using the same foundational patterns
* **Maintainability**: Clear separation of concerns makes the system easier to debug and enhance